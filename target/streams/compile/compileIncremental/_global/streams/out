[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial source changes: [0m
[0m[[0m[0mdebug[0m] [0m[0m	removed:Set(/Users/amrithanayar/IdeaProjects/cats-course/src/main/scala/part1recap/Implicits.scala, /Users/amrithanayar/IdeaProjects/cats-course/src/main/scala/part1recap/Essentials.scala)[0m
[0m[[0m[0mdebug[0m] [0m[0m	added: Set(/Users/amrithanayar/IdeaProjects/cats-course/src/main/scala/part1intro/Essentials.scala, /Users/amrithanayar/IdeaProjects/cats-course/src/main/scala/part1intro/TypeClasses.scala, /Users/amrithanayar/IdeaProjects/cats-course/src/main/scala/part1intro/Implicits.scala, /Users/amrithanayar/IdeaProjects/cats-course/src/main/scala/part1intro/CatsIntro.scala, /Users/amrithanayar/IdeaProjects/cats-course/src/main/scala/part1intro/TCVariance.scala)[0m
[0m[[0m[0mdebug[0m] [0m[0m	modified: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated products: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mExternal API changes: API Changes: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mModified binary dependencies: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial directly invalidated classes: Set(part1recap.Essentials.SequenceChecker, part1recap.Essentials.HigherKindedType, part1recap.Implicits.Cat, part1recap.Implicits.JSONSerializer, part1recap.Essentials, part1recap.Implicits.ImpersonableString, part1recap.Implicits.Person, part1recap.Implicits)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mSources indirectly invalidated by:[0m
[0m[[0m[0mdebug[0m] [0m[0m	product: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0m	binary dep: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0m	external source: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mAll initially invalidated classes: Set(part1recap.Essentials.SequenceChecker, part1recap.Essentials.HigherKindedType, part1recap.Implicits.Cat, part1recap.Implicits.JSONSerializer, part1recap.Essentials, part1recap.Implicits.ImpersonableString, part1recap.Implicits.Person, part1recap.Implicits)[0m
[0m[[0m[0mdebug[0m] [0m[0mAll initially invalidated sources:Set(/Users/amrithanayar/IdeaProjects/cats-course/src/main/scala/part1intro/Essentials.scala, /Users/amrithanayar/IdeaProjects/cats-course/src/main/scala/part1intro/TypeClasses.scala, /Users/amrithanayar/IdeaProjects/cats-course/src/main/scala/part1intro/Implicits.scala, /Users/amrithanayar/IdeaProjects/cats-course/src/main/scala/part1intro/CatsIntro.scala, /Users/amrithanayar/IdeaProjects/cats-course/src/main/scala/part1intro/TCVariance.scala)[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: part1recap.Essentials.SequenceChecker, part1recap.Essentials.HigherKindedType, part1recap.Implicits.Cat, part1recap.Implicits.JSONSerializer, part1recap.Essentials, part1recap.Implicits.ImpersonableString, part1recap.Implicits.Person, part1recap.Implicits[0m
[0m[[0m[0mdebug[0m] [0m[0mRecompiling all sources: number of invalidated sources > 50.0% of all sources[0m
[0m[[0m[0minfo[0m] [0m[0mCompiling 6 Scala sources to /Users/amrithanayar/IdeaProjects/cats-course/target/scala-2.13/classes ...[0m
[0m[[0m[0mdebug[0m] [0m[0mGetting org.scala-sbt:compiler-bridge_2.13:1.3.5:compile for Scala 2.13.3[0m
[0m[[0m[0mdebug[0m] [0m[0mGetting org.scala-sbt:compiler-bridge_2.13:1.3.5:compile for Scala 2.13.3[0m
[0m[[0m[0mdebug[0m] [0m[0m[zinc] Running cached compiler 2bdcc1dd for Scala compiler version 2.13.3[0m
[0m[[0m[0mdebug[0m] [0m[0m[zinc] The Scala compiler is invoked with:[0m
[0m[[0m[0mdebug[0m] [0m[0m	-language:higherKinds[0m
[0m[[0m[0mdebug[0m] [0m[0m	-bootclasspath[0m
[0m[[0m[0mdebug[0m] [0m[0m	/Users/amrithanayar/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.3/scala-library-2.13.3.jar[0m
[0m[[0m[0mdebug[0m] [0m[0m	-classpath[0m
[0m[[0m[0mdebug[0m] [0m[0m	/Users/amrithanayar/IdeaProjects/cats-course/target/scala-2.13/classes:/Users/amrithanayar/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/typelevel/cats-core_2.13/2.1.1/cats-core_2.13-2.1.1.jar:/Users/amrithanayar/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/typelevel/cats-macros_2.13/2.1.1/cats-macros_2.13-2.1.1.jar:/Users/amrithanayar/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/typelevel/cats-kernel_2.13/2.1.1/cats-kernel_2.13-2.1.1.jar[0m
[0m[[0m[0mdebug[0m] [0m[0mScala compilation took 0.488252792 s[0m
[0m[[0m[0minfo[0m] [0m[0mDone compiling.[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from part1intro.Implicits.Person...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: part1intro.Implicits.Person[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(part1intro.Implicits.Person)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(part1intro.Implicits.Person,ModifiedNames(changes = UsedName(part1intro;Implicits;Person;init;,[Default]), UsedName(productPrefix,[Default]), UsedName(wait,[Default]), UsedName(canEqual,[Default]), UsedName(productIterator,[Default]), UsedName(notifyAll,[Default]), UsedName(apply,[Default]), UsedName(hashCode,[Default]), UsedName(copy,[Default]), UsedName(greet,[Default]), UsedName(equals,[Default]), UsedName(unapply,[Default]), UsedName($init$,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productArity,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(copy$default$1,[Default]), UsedName(compose,[Default]), UsedName(productElement,[Default]), UsedName(##,[Default]), UsedName(productElementName,[Default]), UsedName(finalize,[Default]), UsedName(andThen,[Default]), UsedName(productElementNames,[Default]), UsedName(name,[Default]), UsedName(!=,[Default]), UsedName(Person,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The part1intro.Implicits.Person has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(part1intro;Implicits;Person;init;,[Default]), UsedName(productPrefix,[Default]), UsedName(wait,[Default]), UsedName(canEqual,[Default]), UsedName(productIterator,[Default]), UsedName(notifyAll,[Default]), UsedName(apply,[Default]), UsedName(hashCode,[Default]), UsedName(copy,[Default]), UsedName(greet,[Default]), UsedName(equals,[Default]), UsedName(unapply,[Default]), UsedName($init$,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productArity,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(copy$default$1,[Default]), UsedName(compose,[Default]), UsedName(productElement,[Default]), UsedName(##,[Default]), UsedName(productElementName,[Default]), UsedName(finalize,[Default]), UsedName(andThen,[Default]), UsedName(productElementNames,[Default]), UsedName(name,[Default]), UsedName(!=,[Default]), UsedName(Person,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(part1intro.Implicits.Person)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from part1recap.Implicits.Cat...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: part1recap.Implicits.Cat[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(part1recap.Implicits.Cat)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(part1recap.Implicits.Cat,ModifiedNames(changes = UsedName(productPrefix,[Default]), UsedName(wait,[Default]), UsedName(canEqual,[Default]), UsedName(productIterator,[Default]), UsedName(notifyAll,[Default]), UsedName(apply,[Default]), UsedName(hashCode,[Default]), UsedName(part1recap;Implicits;Cat;init;,[Default]), UsedName(copy,[Default]), UsedName(equals,[Default]), UsedName(unapply,[Default]), UsedName($init$,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productArity,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(copy$default$1,[Default]), UsedName(compose,[Default]), UsedName(productElement,[Default]), UsedName(##,[Default]), UsedName(productElementName,[Default]), UsedName(Cat,[Default]), UsedName(finalize,[Default]), UsedName(andThen,[Default]), UsedName(productElementNames,[Default]), UsedName(name,[Default]), UsedName(!=,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The part1recap.Implicits.Cat has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(productPrefix,[Default]), UsedName(wait,[Default]), UsedName(canEqual,[Default]), UsedName(productIterator,[Default]), UsedName(notifyAll,[Default]), UsedName(apply,[Default]), UsedName(hashCode,[Default]), UsedName(part1recap;Implicits;Cat;init;,[Default]), UsedName(copy,[Default]), UsedName(equals,[Default]), UsedName(unapply,[Default]), UsedName($init$,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productArity,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(copy$default$1,[Default]), UsedName(compose,[Default]), UsedName(productElement,[Default]), UsedName(##,[Default]), UsedName(productElementName,[Default]), UsedName(Cat,[Default]), UsedName(finalize,[Default]), UsedName(andThen,[Default]), UsedName(productElementNames,[Default]), UsedName(name,[Default]), UsedName(!=,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(part1recap.Implicits.Cat)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from part1intro.TCVariance...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: part1intro.TCVariance[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(part1intro.TCVariance)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(part1intro.TCVariance,ModifiedNames(changes = UsedName(AnimalSoundMaker,[Implicit]), UsedName(GeneralAnimalShow,[Implicit]), UsedName(wait,[Default]), UsedName(aComparison,[Default]), UsedName(notifyAll,[Default]), UsedName(organizeShow,[Default]), UsedName(main,[Default]), UsedName(hashCode,[Default]), UsedName(CatsShow,[Implicit]), UsedName(equals,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(OptionSoundMaker,[Implicit]), UsedName(asInstanceOf,[Default]), UsedName(Vet,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(TCVariance,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(cage,[Default]), UsedName(AnimalShow,[Default]), UsedName(SoundMaker,[Default]), UsedName(##,[Default]), UsedName(Cat,[Default]), UsedName(finalize,[Default]), UsedName(Cage,[Default]), UsedName(makeSound,[Default]), UsedName(Animal,[Default]), UsedName(!=,[Default]), UsedName(vet,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The part1intro.TCVariance has the following implicit definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(AnimalSoundMaker,[Implicit]), UsedName(GeneralAnimalShow,[Implicit]), UsedName(CatsShow,[Implicit]), UsedName(OptionSoundMaker,[Implicit]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(part1intro.TCVariance)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from part1intro.TCVariance.Animal...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: part1intro.TCVariance.Animal[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding part1intro.TCVariance.Cat by part1intro.TCVariance.Animal[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(part1intro.TCVariance.Animal, part1intro.TCVariance.Cat)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(part1intro.TCVariance.Animal,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(notifyAll,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(part1intro;TCVariance;Animal;init;,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(Animal,[Default]), UsedName(!=,[Default]), UsedName(toString,[Default]))) invalidates 2 classes due to The part1intro.TCVariance.Animal has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(wait,[Default]), UsedName(notifyAll,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(part1intro;TCVariance;Animal;init;,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(Animal,[Default]), UsedName(!=,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(part1intro.TCVariance.Animal, part1intro.TCVariance.Cat)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from part1intro.CatsIntro.ToyCar...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: part1intro.CatsIntro.ToyCar[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(part1intro.CatsIntro.ToyCar)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(part1intro.CatsIntro.ToyCar,ModifiedNames(changes = UsedName(productPrefix,[Default]), UsedName(wait,[Default]), UsedName(canEqual,[Default]), UsedName(productIterator,[Default]), UsedName(notifyAll,[Default]), UsedName(apply,[Default]), UsedName(hashCode,[Default]), UsedName(part1intro;CatsIntro;ToyCar;init;,[Default]), UsedName(copy$default$2,[Default]), UsedName(tupled,[Default]), UsedName(copy,[Default]), UsedName(equals,[Default]), UsedName(curried,[Default]), UsedName(unapply,[Default]), UsedName($init$,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(model,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productArity,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(clone,[Default]), UsedName(ToyCar,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(copy$default$1,[Default]), UsedName(price,[Default]), UsedName(productElement,[Default]), UsedName(##,[Default]), UsedName(productElementName,[Default]), UsedName(finalize,[Default]), UsedName(productElementNames,[Default]), UsedName(!=,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The part1intro.CatsIntro.ToyCar has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(productPrefix,[Default]), UsedName(wait,[Default]), UsedName(canEqual,[Default]), UsedName(productIterator,[Default]), UsedName(notifyAll,[Default]), UsedName(apply,[Default]), UsedName(hashCode,[Default]), UsedName(part1intro;CatsIntro;ToyCar;init;,[Default]), UsedName(copy$default$2,[Default]), UsedName(tupled,[Default]), UsedName(copy,[Default]), UsedName(equals,[Default]), UsedName(curried,[Default]), UsedName(unapply,[Default]), UsedName($init$,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(model,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productArity,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(clone,[Default]), UsedName(ToyCar,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(copy$default$1,[Default]), UsedName(price,[Default]), UsedName(productElement,[Default]), UsedName(##,[Default]), UsedName(productElementName,[Default]), UsedName(finalize,[Default]), UsedName(productElementNames,[Default]), UsedName(!=,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(part1intro.CatsIntro.ToyCar)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from part1intro.TCVariance.AnimalSoundMaker...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: part1intro.TCVariance.AnimalSoundMaker[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(part1intro.TCVariance.AnimalSoundMaker)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(part1intro.TCVariance.AnimalSoundMaker,ModifiedNames(changes = UsedName(AnimalSoundMaker,[Implicit]), UsedName(wait,[Default]), UsedName(notifyAll,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(!=,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The part1intro.TCVariance.AnimalSoundMaker has the following implicit definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(AnimalSoundMaker,[Implicit]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(part1intro.TCVariance.AnimalSoundMaker)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from part1intro.Implicits.JSONSerializer...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: part1intro.Implicits.JSONSerializer[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(part1intro.Implicits.JSONSerializer)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidate by local inheritance: part1intro.Implicits.JSONSerializer -> Set(part1intro.Implicits)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(part1intro.Implicits.JSONSerializer,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(notifyAll,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(JSONSerializer,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(##,[Default]), UsedName(toJson,[Default]), UsedName(finalize,[Default]), UsedName(!=,[Default]), UsedName(toString,[Default]))) invalidates 2 classes due to The part1intro.Implicits.JSONSerializer has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(wait,[Default]), UsedName(notifyAll,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(JSONSerializer,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(##,[Default]), UsedName(toJson,[Default]), UsedName(finalize,[Default]), UsedName(!=,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(part1intro.Implicits.JSONSerializer)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by local inheritance: Set(part1intro.Implicits)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from part1intro.TCVariance.OptionSoundMaker...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: part1intro.TCVariance.OptionSoundMaker[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(part1intro.TCVariance.OptionSoundMaker)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(part1intro.TCVariance.OptionSoundMaker,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(notifyAll,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(OptionSoundMaker,[Implicit]), UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(!=,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The part1intro.TCVariance.OptionSoundMaker has the following implicit definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(OptionSoundMaker,[Implicit]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(part1intro.TCVariance.OptionSoundMaker)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from part1intro.TCVariance.GeneralAnimalShow...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: part1intro.TCVariance.GeneralAnimalShow[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(part1intro.TCVariance.GeneralAnimalShow)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(part1intro.TCVariance.GeneralAnimalShow,ModifiedNames(changes = UsedName(GeneralAnimalShow,[Implicit]), UsedName(wait,[Default]), UsedName(notifyAll,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(##,[Default]), UsedName(show,[Default]), UsedName(finalize,[Default]), UsedName(!=,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The part1intro.TCVariance.GeneralAnimalShow has the following implicit definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(GeneralAnimalShow,[Implicit]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(part1intro.TCVariance.GeneralAnimalShow)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from part1intro.TCVariance.SoundMaker...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: part1intro.TCVariance.SoundMaker[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding part1intro.TCVariance.OptionSoundMaker by part1intro.TCVariance.SoundMaker[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding part1intro.TCVariance.AnimalSoundMaker by part1intro.TCVariance.SoundMaker[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(part1intro.TCVariance.AnimalSoundMaker, part1intro.TCVariance.OptionSoundMaker, part1intro.TCVariance.SoundMaker)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(part1intro.TCVariance.SoundMaker,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(notifyAll,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(SoundMaker,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(!=,[Default]), UsedName(toString,[Default]))) invalidates 3 classes due to The part1intro.TCVariance.SoundMaker has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(wait,[Default]), UsedName(notifyAll,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(SoundMaker,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(!=,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(part1intro.TCVariance.AnimalSoundMaker, part1intro.TCVariance.OptionSoundMaker, part1intro.TCVariance.SoundMaker)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from part1recap.Essentials.SequenceChecker...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: part1recap.Essentials.SequenceChecker[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(part1recap.Essentials.SequenceChecker)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(part1recap.Essentials.SequenceChecker,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(notifyAll,[Default]), UsedName(hashCode,[Default]), UsedName(isSequential,[Default]), UsedName(SequenceChecker,[Default]), UsedName(equals,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(!=,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The part1recap.Essentials.SequenceChecker has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(wait,[Default]), UsedName(notifyAll,[Default]), UsedName(hashCode,[Default]), UsedName(isSequential,[Default]), UsedName(SequenceChecker,[Default]), UsedName(equals,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(!=,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(part1recap.Essentials.SequenceChecker)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from part1recap.Essentials...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: part1recap.Essentials[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(part1recap.Essentials)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(part1recap.Essentials,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(notifyAll,[Default]), UsedName(checkerboard,[Default]), UsedName(main,[Default]), UsedName(hashCode,[Default]), UsedName(SequenceChecker,[Default]), UsedName(equals,[Default]), UsedName(Essentials,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(listChecker,[Default]), UsedName(partialFuncion,[Default]), UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(clone,[Default]), UsedName(incrementer,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(HigherKindedType,[Default]), UsedName(##,[Default]), UsedName(alsoCheckerboard,[Default]), UsedName(finalize,[Default]), UsedName(!=,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The part1recap.Essentials has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(wait,[Default]), UsedName(notifyAll,[Default]), UsedName(checkerboard,[Default]), UsedName(main,[Default]), UsedName(hashCode,[Default]), UsedName(SequenceChecker,[Default]), UsedName(equals,[Default]), UsedName(Essentials,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(listChecker,[Default]), UsedName(partialFuncion,[Default]), UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(clone,[Default]), UsedName(incrementer,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(HigherKindedType,[Default]), UsedName(##,[Default]), UsedName(alsoCheckerboard,[Default]), UsedName(finalize,[Default]), UsedName(!=,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(part1recap.Essentials)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from part1recap.Essentials.HigherKindedType...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: part1recap.Essentials.HigherKindedType[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(part1recap.Essentials.HigherKindedType)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(part1recap.Essentials.HigherKindedType,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(notifyAll,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(HigherKindedType,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(!=,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The part1recap.Essentials.HigherKindedType has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(wait,[Default]), UsedName(notifyAll,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(HigherKindedType,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(!=,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(part1recap.Essentials.HigherKindedType)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from part1intro.Essentials...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: part1intro.Essentials[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(part1intro.Essentials)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(part1intro.Essentials,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(notifyAll,[Default]), UsedName(checkerboard,[Default]), UsedName(main,[Default]), UsedName(hashCode,[Default]), UsedName(SequenceChecker,[Default]), UsedName(equals,[Default]), UsedName(Essentials,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(listChecker,[Default]), UsedName(partialFuncion,[Default]), UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(clone,[Default]), UsedName(incrementer,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(HigherKindedType,[Default]), UsedName(##,[Default]), UsedName(alsoCheckerboard,[Default]), UsedName(finalize,[Default]), UsedName(!=,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The part1intro.Essentials has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(wait,[Default]), UsedName(notifyAll,[Default]), UsedName(checkerboard,[Default]), UsedName(main,[Default]), UsedName(hashCode,[Default]), UsedName(SequenceChecker,[Default]), UsedName(equals,[Default]), UsedName(Essentials,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(listChecker,[Default]), UsedName(partialFuncion,[Default]), UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(clone,[Default]), UsedName(incrementer,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(HigherKindedType,[Default]), UsedName(##,[Default]), UsedName(alsoCheckerboard,[Default]), UsedName(finalize,[Default]), UsedName(!=,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(part1intro.Essentials)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from part1intro.TCVariance.Cat...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: part1intro.TCVariance.Cat[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(part1intro.TCVariance.Cat)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(part1intro.TCVariance.Cat,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(part1intro;TCVariance;Cat;init;,[Default]), UsedName(notifyAll,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(##,[Default]), UsedName(Cat,[Default]), UsedName(finalize,[Default]), UsedName(!=,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The part1intro.TCVariance.Cat has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(wait,[Default]), UsedName(part1intro;TCVariance;Cat;init;,[Default]), UsedName(notifyAll,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(##,[Default]), UsedName(Cat,[Default]), UsedName(finalize,[Default]), UsedName(!=,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(part1intro.TCVariance.Cat)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from part1intro.TCVariance.CatsShow...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: part1intro.TCVariance.CatsShow[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(part1intro.TCVariance.CatsShow)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(part1intro.TCVariance.CatsShow,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(notifyAll,[Default]), UsedName(hashCode,[Default]), UsedName(CatsShow,[Implicit]), UsedName(equals,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(##,[Default]), UsedName(show,[Default]), UsedName(finalize,[Default]), UsedName(!=,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The part1intro.TCVariance.CatsShow has the following implicit definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(CatsShow,[Implicit]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(part1intro.TCVariance.CatsShow)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from part1intro.Implicits...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: part1intro.Implicits[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(part1intro.Implicits)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(part1intro.Implicits,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(notifyAll,[Default]), UsedName(personsJson,[Default]), UsedName(main,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(listToJson,[Default]), UsedName(asInstanceOf,[Default]), UsedName(impersonableString,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(JSONSerializer,[Default]), UsedName(clone,[Default]), UsedName(catsToJson,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(greeting,[Default]), UsedName(oneArgCaseClassSerializer,[Implicit]), UsedName(##,[Default]), UsedName(Implicits,[Default]), UsedName(personSerializer,[Implicit]), UsedName(Cat,[Default]), UsedName(finalize,[Default]), UsedName(!=,[Default]), UsedName(ImpersonableString,[Implicit]), UsedName(Person,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The part1intro.Implicits has the following implicit definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(oneArgCaseClassSerializer,[Implicit]), UsedName(personSerializer,[Implicit]), UsedName(ImpersonableString,[Implicit]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(part1intro.Implicits)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from part1recap.Implicits.Person...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: part1recap.Implicits.Person[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(part1recap.Implicits.Person)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(part1recap.Implicits.Person,ModifiedNames(changes = UsedName(productPrefix,[Default]), UsedName(wait,[Default]), UsedName(canEqual,[Default]), UsedName(productIterator,[Default]), UsedName(notifyAll,[Default]), UsedName(apply,[Default]), UsedName(part1recap;Implicits;Person;init;,[Default]), UsedName(hashCode,[Default]), UsedName(copy,[Default]), UsedName(greet,[Default]), UsedName(equals,[Default]), UsedName(unapply,[Default]), UsedName($init$,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productArity,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(copy$default$1,[Default]), UsedName(compose,[Default]), UsedName(productElement,[Default]), UsedName(##,[Default]), UsedName(productElementName,[Default]), UsedName(finalize,[Default]), UsedName(andThen,[Default]), UsedName(productElementNames,[Default]), UsedName(name,[Default]), UsedName(!=,[Default]), UsedName(Person,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The part1recap.Implicits.Person has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(productPrefix,[Default]), UsedName(wait,[Default]), UsedName(canEqual,[Default]), UsedName(productIterator,[Default]), UsedName(notifyAll,[Default]), UsedName(apply,[Default]), UsedName(part1recap;Implicits;Person;init;,[Default]), UsedName(hashCode,[Default]), UsedName(copy,[Default]), UsedName(greet,[Default]), UsedName(equals,[Default]), UsedName(unapply,[Default]), UsedName($init$,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productArity,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(copy$default$1,[Default]), UsedName(compose,[Default]), UsedName(productElement,[Default]), UsedName(##,[Default]), UsedName(productElementName,[Default]), UsedName(finalize,[Default]), UsedName(andThen,[Default]), UsedName(productElementNames,[Default]), UsedName(name,[Default]), UsedName(!=,[Default]), UsedName(Person,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(part1recap.Implicits.Person)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from part1intro.Essentials.HigherKindedType...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: part1intro.Essentials.HigherKindedType[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(part1intro.Essentials.HigherKindedType)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(part1intro.Essentials.HigherKindedType,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(notifyAll,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(HigherKindedType,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(!=,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The part1intro.Essentials.HigherKindedType has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(wait,[Default]), UsedName(notifyAll,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(HigherKindedType,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(!=,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(part1intro.Essentials.HigherKindedType)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from part1intro.TypeClasses...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: part1intro.TypeClasses[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(part1intro.TypeClasses)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(part1intro.TypeClasses,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(notifyAll,[Default]), UsedName(main,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(TypeClasses,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(!=,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The part1intro.TypeClasses has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(wait,[Default]), UsedName(notifyAll,[Default]), UsedName(main,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(TypeClasses,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(!=,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(part1intro.TypeClasses)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from part1intro.TCVariance.Cage...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: part1intro.TCVariance.Cage[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(part1intro.TCVariance.Cage)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(part1intro.TCVariance.Cage,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(notifyAll,[Default]), UsedName(hashCode,[Default]), UsedName(part1intro;TCVariance;Cage;init;,[Default]), UsedName(equals,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(Cage,[Default]), UsedName(!=,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The part1intro.TCVariance.Cage has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(wait,[Default]), UsedName(notifyAll,[Default]), UsedName(hashCode,[Default]), UsedName(part1intro;TCVariance;Cage;init;,[Default]), UsedName(equals,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(Cage,[Default]), UsedName(!=,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(part1intro.TCVariance.Cage)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from part1intro.TCVariance.AnimalShow...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: part1intro.TCVariance.AnimalShow[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding part1intro.TCVariance.GeneralAnimalShow by part1intro.TCVariance.AnimalShow[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding part1intro.TCVariance.CatsShow by part1intro.TCVariance.AnimalShow[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(part1intro.TCVariance.AnimalShow, part1intro.TCVariance.CatsShow, part1intro.TCVariance.GeneralAnimalShow)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(part1intro.TCVariance.AnimalShow,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(notifyAll,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(AnimalShow,[Default]), UsedName(##,[Default]), UsedName(show,[Default]), UsedName(finalize,[Default]), UsedName(!=,[Default]), UsedName(toString,[Default]))) invalidates 3 classes due to The part1intro.TCVariance.AnimalShow has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(wait,[Default]), UsedName(notifyAll,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(AnimalShow,[Default]), UsedName(##,[Default]), UsedName(show,[Default]), UsedName(finalize,[Default]), UsedName(!=,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(part1intro.TCVariance.AnimalShow, part1intro.TCVariance.CatsShow, part1intro.TCVariance.GeneralAnimalShow)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from part1recap.Implicits...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: part1recap.Implicits[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(part1recap.Implicits)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(part1recap.Implicits,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(notifyAll,[Default]), UsedName(personsJson,[Default]), UsedName(main,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(listToJson,[Default]), UsedName(asInstanceOf,[Default]), UsedName(impersonableString,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(JSONSerializer,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(greeting,[Default]), UsedName(oneArgCaseClassSerializer,[Implicit]), UsedName(##,[Default]), UsedName(Implicits,[Default]), UsedName(personSerializer,[Implicit]), UsedName(Cat,[Default]), UsedName(finalize,[Default]), UsedName(!=,[Default]), UsedName(ImpersonableString,[Implicit]), UsedName(Person,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The part1recap.Implicits has the following implicit definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(oneArgCaseClassSerializer,[Implicit]), UsedName(personSerializer,[Implicit]), UsedName(ImpersonableString,[Implicit]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(part1recap.Implicits)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from part1intro.TCVariance.Vet...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: part1intro.TCVariance.Vet[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(part1intro.TCVariance.Vet)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(part1intro.TCVariance.Vet,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(part1intro;TCVariance;Vet;init;,[Default]), UsedName(notifyAll,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(Vet,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(!=,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The part1intro.TCVariance.Vet has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(wait,[Default]), UsedName(part1intro;TCVariance;Vet;init;,[Default]), UsedName(notifyAll,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(Vet,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(!=,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(part1intro.TCVariance.Vet)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from part1intro.CatsIntro...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: part1intro.CatsIntro[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(part1intro.CatsIntro)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(part1intro.CatsIntro,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(notifyAll,[Default]), UsedName(anotherTypeSafeComparison,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]), UsedName(aTypeSafeComparison,[Default]), UsedName(toyCarEq,[Implicit]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(clone,[Default]), UsedName(aListComparison,[Default]), UsedName(ToyCar,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(##,[Default]), UsedName(notEqualComparison,[Default]), UsedName(finalize,[Default]), UsedName(CatsIntro,[Default]), UsedName(compare2ToyCards,[Default]), UsedName(!=,[Default]), UsedName(intEquality,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The part1intro.CatsIntro has the following implicit definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(toyCarEq,[Implicit]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(part1intro.CatsIntro)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from part1intro.Essentials.SequenceChecker...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: part1intro.Essentials.SequenceChecker[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(part1intro.Essentials.SequenceChecker)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidate by local inheritance: part1intro.Essentials.SequenceChecker -> Set(part1intro.Essentials)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(part1intro.Essentials.SequenceChecker,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(notifyAll,[Default]), UsedName(hashCode,[Default]), UsedName(isSequential,[Default]), UsedName(SequenceChecker,[Default]), UsedName(equals,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(!=,[Default]), UsedName(toString,[Default]))) invalidates 2 classes due to The part1intro.Essentials.SequenceChecker has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(wait,[Default]), UsedName(notifyAll,[Default]), UsedName(hashCode,[Default]), UsedName(isSequential,[Default]), UsedName(SequenceChecker,[Default]), UsedName(equals,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(!=,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(part1intro.Essentials.SequenceChecker)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by local inheritance: Set(part1intro.Essentials)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from part1recap.Implicits.JSONSerializer...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: part1recap.Implicits.JSONSerializer[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(part1recap.Implicits.JSONSerializer)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(part1recap.Implicits.JSONSerializer,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(notifyAll,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(JSONSerializer,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(##,[Default]), UsedName(toJson,[Default]), UsedName(finalize,[Default]), UsedName(!=,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The part1recap.Implicits.JSONSerializer has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(wait,[Default]), UsedName(notifyAll,[Default]), UsedName(hashCode,[Default]), UsedName(equals,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(JSONSerializer,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(##,[Default]), UsedName(toJson,[Default]), UsedName(finalize,[Default]), UsedName(!=,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(part1recap.Implicits.JSONSerializer)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from part1intro.Implicits.Cat...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: part1intro.Implicits.Cat[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(part1intro.Implicits.Cat)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(part1intro.Implicits.Cat,ModifiedNames(changes = UsedName(productPrefix,[Default]), UsedName(wait,[Default]), UsedName(part1intro;Implicits;Cat;init;,[Default]), UsedName(canEqual,[Default]), UsedName(productIterator,[Default]), UsedName(notifyAll,[Default]), UsedName(apply,[Default]), UsedName(hashCode,[Default]), UsedName(copy,[Default]), UsedName(equals,[Default]), UsedName(unapply,[Default]), UsedName($init$,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productArity,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(copy$default$1,[Default]), UsedName(compose,[Default]), UsedName(productElement,[Default]), UsedName(##,[Default]), UsedName(productElementName,[Default]), UsedName(Cat,[Default]), UsedName(finalize,[Default]), UsedName(andThen,[Default]), UsedName(productElementNames,[Default]), UsedName(name,[Default]), UsedName(!=,[Default]), UsedName(toString,[Default]))) invalidates 1 classes due to The part1intro.Implicits.Cat has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(productPrefix,[Default]), UsedName(wait,[Default]), UsedName(part1intro;Implicits;Cat;init;,[Default]), UsedName(canEqual,[Default]), UsedName(productIterator,[Default]), UsedName(notifyAll,[Default]), UsedName(apply,[Default]), UsedName(hashCode,[Default]), UsedName(copy,[Default]), UsedName(equals,[Default]), UsedName(unapply,[Default]), UsedName($init$,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productArity,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(copy$default$1,[Default]), UsedName(compose,[Default]), UsedName(productElement,[Default]), UsedName(##,[Default]), UsedName(productElementName,[Default]), UsedName(Cat,[Default]), UsedName(finalize,[Default]), UsedName(andThen,[Default]), UsedName(productElementNames,[Default]), UsedName(name,[Default]), UsedName(!=,[Default]), UsedName(toString,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(part1intro.Implicits.Cat)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from part1recap.Implicits.ImpersonableString...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: part1recap.Implicits.ImpersonableString[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(part1recap.Implicits.ImpersonableString)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(part1recap.Implicits.ImpersonableString,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(notifyAll,[Default]), UsedName(hashCode,[Default]), UsedName(greet,[Default]), UsedName(equals,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(!=,[Default]), UsedName(part1recap;Implicits;ImpersonableString;init;,[Default]), UsedName(ImpersonableString,[Implicit]), UsedName(toString,[Default]))) invalidates 1 classes due to The part1recap.Implicits.ImpersonableString has the following implicit definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(ImpersonableString,[Implicit]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(part1recap.Implicits.ImpersonableString)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from part1intro.Implicits.ImpersonableString...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: part1intro.Implicits.ImpersonableString[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(part1intro.Implicits.ImpersonableString)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(part1intro.Implicits.ImpersonableString,ModifiedNames(changes = UsedName(wait,[Default]), UsedName(notifyAll,[Default]), UsedName(hashCode,[Default]), UsedName(greet,[Default]), UsedName(equals,[Default]), UsedName(isInstanceOf,[Default]), UsedName(ne,[Default]), UsedName(asInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(getClass,[Default]), UsedName(clone,[Default]), UsedName(eq,[Default]), UsedName(notify,[Default]), UsedName(==,[Default]), UsedName(##,[Default]), UsedName(finalize,[Default]), UsedName(part1intro;Implicits;ImpersonableString;init;,[Default]), UsedName(!=,[Default]), UsedName(ImpersonableString,[Implicit]), UsedName(toString,[Default]))) invalidates 1 classes due to The part1intro.Implicits.ImpersonableString has the following implicit definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(ImpersonableString,[Implicit]).[0m
[0m[[0m[0mdebug[0m] [0m[0m	> by transitive inheritance: Set(part1intro.Implicits.ImpersonableString)[0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m	> [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mNew invalidations:[0m
[0m[[0m[0mdebug[0m] [0m[0m	Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: [0m
[0m[[0m[0mdebug[0m] [0m[0mPreviously invalidated, but (transitively) depend on new invalidations:[0m
[0m[[0m[0mdebug[0m] [0m[0m	Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mNo classes were invalidated.[0m
